## TODOLIST ##

需要确认接口是否需要登录

## 1/9 ##

结构继续搭建，stylus+主题色提前声明。
基本确定要用flex布局+Rem
做了一下别名处理
下载图标非常麻烦
## 1/10 ##

登陆是件挺复杂的事情，我可能需要先写登陆组件
先简单写个弱智的登录组件吧，后续的样式验证逻辑都到后面再写。
把用户的登录状态和基本用户信息缓存到的LocaStorage，接下来的很多组件可能都要依赖这些状态，不然全部放置到app组件可能会过于重度了。

明天需要做一下按钮点击时候的偏移缩小效果，这样感觉会好很多

## 1/11 ##

三元表达式得用[]括起来
不在Typescript的配置文件中 'lib'增加DOM就无法使用window对象
实在TS阻止你，而你又知道这么写每次就用 （x as type）来进行强制断言吧


## 1/12 ##

让flex的子元素不弹性的方法就是设置他的shark，为0即任何情况下都不会缩


## 1/13 ##

今天对一个开源项目做了点贡献，增加了点功能，

开始做主要的路由部分,尽量吧内部的菜单抽离成一个数据文件，导入循环渲染来进行菜单的渲染
Router-link默认会阻止click事件哦，所以还是用编程式导航吧

## 1/14 ##

写了个爬虫来爬取Banner数据

## 1/15 ##

建立响应式的carsouel

## 1/16 ##

完成响应式的轮播图等

## 1/17 ##

完成响应式推荐菜单和歌单推荐，并做到任何大小的屏幕都能完美适配

今天知道了如果是CROS跨域请求想带cookie的话必须加上一个参数` .withCredentials() `
如果想做到任何情况子元素随着父元素自适应，单纯flex是不够的，需要使用百分百的宽度+媒体查询。

flex在大多数情况下都能完美替代大部分布局方案，我觉得非常棒。

想出一个基本准则，所有组件调用需要传入三个props和以上的，我全部以对象的形式去传参，同时也需要考虑这个组件是否会在很多地方调用，在那些地方调用的时候接口是否相同，如果不相同那么传入一个对象可能会让这个组件不够灵活，散一点可能会更棒


重构了很多东西，比如props的替换，CSSmixins。很多API函数名都被更好的命名



## 1/20 ##

做了大量的lazy-load处理，以及Loadding动画，完成了无限加载的歌单页面。

重构了诸多组件，使其能够更好的复用。

写了一个动画组件，可以实现极高的复用率

提升了性能

还是放弃了性能，因为如果我使用组件复用，那么组件的背景图很难被重置为placeholerimg。我一旦vshow=false之后更新src就不会被vue响应。这会导致提升不到半秒的性能带来相当高额的代码量。并且结构会混乱很多。感觉得不偿失。

## 1/22 ##

完成了歌单列表的页面，整体进度应该来说比较慢，不过没啥关系，因为我时间很多。
用了相当大量的时间去修改一些依赖组件和具体的样式，尽量做到仿真度高一点吧。

增加了本地API接口缓存机制，可以提升一些并不是经常更新的接口的访问速度，时间目前预设为6小时

增加了mixins系统

一个API无法满足我的需求，所以手动修改一下因为需要cookie所以还是放弃，打算前端缓慢去抓取一部分，然后长期保存

## 1/23 ##

对于歌手页面使用了前端并发抓取数据+合成+重新排序的方法，然后利用本地缓存。借助了一个拼音库

## 1/24 ##

这API歌手页面实在是难搞，数量太少了，抓1000个歌手实际可能只有200个

进入新的底部，歌单组件

打算在所有详情组件，比如歌单，歌手，电台，外面都加一层detail组件，以便复用滚动

考虑再三决定放弃一些组件导入上面的mixin，还是方法和属性会有更加强的mixin必要

对于歌单详情的BUG进行了修复，帮助开源项目　


## 1/25 ##

如果想要在某个实例的prototype上增加一些方法，需要在d.ts文件中声明

比如声明这样一个方法

```js

declare interface Date {
  Format(date: any): string
}

```

## 1/26 ##

歌单基本完成 明天开发播放器。
一定要记得scoped 不然出现很多奇奇怪怪的情况

完成了播放数据的缓存

重构了很多文件结构，让他们的行为更加单一

TODO: 初始化数据文件的合并，common必须重新整合 缓存需要更加的统一集中


## 1/27 ##

播放进度拖动的
flex-shriack是伸缩，是空间不足情况下的伸缩率

```js

*playModeFSM(Cmode: number) {
    let first,
      next = []
    for (let key in Object.keys(playMode)) {
      if (playMode[key] === Cmode) {
        first = Cmode
      } else {
        next.push(playMode[key])
      }
    }
    while(true){
      yield first
      for(let n of next){
        yield n
      }
    }
  }

```

flex有个玩法是给固定的宽度，但是让他grow， 这个宽度最后会成为他的最小值shrik = 0

基本完成了播放器的功能 模式切换什么的，还得加上播放加载音乐时的加载动画，还有没有音乐的基本样式，可以加载一个默认的currentSong



## 注意 如果在Vue组件里对DOM强依赖，比如在组件mounted的时候利用Nexttick来获取某个DOM的宽度，就必须使用if条件渲染，如果使用v-show。在执行生命周期的时候这个组件根本还没有被加载到DOM中。

修复了很多歌词模块的BUG 开发近似歌曲模块


在歌单/歌手/专辑详情页面我放弃了用一个mask背景覆盖然后展示Loading动画的想法，通过这个肯定可以一定程度上的提高性能，但为了提升可能不到.1秒的速度，我需要在每个详情组件内部去实现mask，我觉得这违背了单一行为的原则，让本来的组件变得更加的混乱。还是使用当ID更改的时候，重初始化数据，虽然会丢失原有的一些DOM借点，会重新渲染，但感觉还不错


TODO: 为了让这个APP更加好用，我需要在后续在增加很多的边界处理，比如当获取不到数据的时候就提醒并返回上一级。

缓存对于时间根本没要求，让他timeout五秒再真正的写入，这样可以极大的提升性能

```js

function isSameArrayAttr(attr: string, arr1: Array<any>, arr2: Array<any>) {
  const al = arr1.length
  const bl = arr2.length
  const target = al > 50 ? Math.floor(al / 10) : al
  if (al !== bl) return false
  // 抽查
  for (let i = 0; i < target; i++) {
    let index = Math.floor(Math.random() * al)
    if (arr1[index][attr] !== arr2[index][attr]) {
      return false
    }
  }
  return true
}

```

必须在更改播放列表前检查是否相同，如果相同只需要改变一下Indexx就可以了，但是比较的方法用tostring不好太慢了。用这个能降低到几乎很低很低


搜索页面的动态性非常的高，我对每一个子组件都使用了一个状态机，通过对应不同的状态来进行一些比如loading,没有结果的提示，等等
否则管理起来其实会比较的复杂
```js

const resultState = {
  wait: 1,
  init: 0,
  noResult: 2,
  hasResult: 3
}

```


要避免使用一些非常奇怪的技巧，比如在windows上加上点击事件来保证点击除了某个组件以外的部分都会让这个组件关闭，这有可能会导致点击一些其他的交互而导致这个组件过于快的被关闭，一些事件可能无法被处罚，更好的选择是利用mask来进行遮罩

正向反查是一项非常有用的技术，可以免除很多边界情况下的问题